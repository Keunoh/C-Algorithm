C algorithm for fun.. 👾🧠👨‍💻🦽

### --- `02 배열` ---
# 02-1 배열 (Array)
배열은 같은 자료형의 변수로 이루어진 요소(element)가 모여 직선 모양으로 줄지어 있는 자료구조입니다.
배열 요소의 자료형은 int형이나 double형 등 어떤 형이든 상관없습니다.
### 자료구조
데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계
- 데이터와 단위 자료 구조
  - 데이터 단위는 데이터를 구성하는 한 덩어리라고 생각하면 됩니다. 그리고 자료구조는 쉽게 말해 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법을 말합니다.

### --- `04 스택과 큐` ---
# 04-1 스택 (Stack)
스택은 데이터를 일시적으로 저장하기 위한 자료구조로, 가장 나중에 넣은 데이터를 가장 먼저 꺼냅니다.
### 스택이란?
스택(Stack)은 데이터를 일시적으로 저장하기 위해 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO, Last In First Out)입니다(가장 나중에 넣은 데이터를 가장 먼저 꺼냅니다).
스택에 데이터를 넣는 작업을 푸시(push)라 하고, 스택에서 데이터를 꺼내는 작업을 팝(pop)이라고 합니다.
테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행합니다.
이렇게 푸시, 팝을 하는 위치를 꼭대기(top)라 하고, 스택의 가장 밑바닥 부분을 바닥(bottom)이라고 합니다.

# 04-02 큐 (Queue)
이번에 살펴볼 큐는 스택과 마찬가지로 데이터를 일시적으로 쌓아 놓은 자료구조입니다.
하지만 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출(FIFO; First In First Out)인 점이 스택과 다릅니다.
### 큐란?
큐(queue)는 스택과 마찬가지로 데이터를 일시적으로 쌓아 두기 위한 자료구조입니다.
가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조를 이루고 있습니다.
생활에서 볼 수 있는 큐의 예는 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열을 들 수 있습니다.
- 만약 이렇게 기다리는 대기열이 '스택'이라면 가장 먼저 줄을 선 사람이 가장 늦게까지 기다리게 됩니다.

큐에 데이터를 넣는 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 디큐(dequeue)라고 합니다.
또 데이터를 꺼내는 쪽을 프런트(front)라 하고, 데이터를 넣는 쪽을 리어(rear)라고 합니다.

### ---`05 재귀 알고리즘`---
### 05-1 재귀(Recursive) 
- 어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의될 때
재귀적(recursive)이라고 합니다.
	
- ex) 조건 1. 1은 자연수입니다.  
조건 2. 자연수 n의 바로 다음 수도 자연수입니다.	

1. `순차곱셈(Factorial)`
	- 그 수보다 작거나 같은 모든 양의 정수의 곱이다.

	- ex) 조건 1. 0! = 1  
	조건2. n > 0 이면 n! = n * (n -1)!

2. `재귀호출(Recursive Call)`
	
	- 재귀 호출은 '함수 자신'을 호출한다고 이해하기보다는 '자기 자신과 똑같은 함수'를 호출한다고 이해하는 것이 자연스럽습니다. 만약 진짜로 함수 자신을 호출하면 끝없이 자	기 자신을 호출하는 행위를 계속할 테니까요.
	
3. `직접(direct) 재귀와 간접(indirect) 재귀`  
	- 이처럼 자신과 같은 함수를 호출하면 직접재귀이고, 간접재귀는 함수 a가 함수 b를 호출하고, 다시 함수 b가 함수 a를 호출하는 구조로 이루어집니다.

4. `유클리드 호제법(Euclidean method of mutual division)`
	
	- 두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법 직사각형을 정사각형으로 완전히 채웁니다. 이렇게 만들 수 있는 정사각형의 가장 긴 변의 길이를 구하세요.
	
	- 이렇게 두 정수가 주어질 경우 큰 값을 작은 값으로 나누었을 때 나누어 떨어지는 가장 작은 값이 최대공약수입니다. 나누어지지 않으면 작은 값(얻은 나머지)에 대해 나누어 떨어질 때까지 같은 과정을 재귀적으로 반복합니다.

### 05-2 재귀 알고리즘 분석
- 하향식 분석 : 가장 위쪽에 위치한 상자의 함수 호출부터 시작해 계단식으로자세히 조사해 가는 분석 기법을 하향식 분석(top-down analysis)이라고 합니다.

- 상향식 분석 : 위쪽부터 분석하는 햐향식 분석과는 대조적으로 아래쪽부터 쌓아 올리며 분석하는 방법이 상향식 분석(bottom-up analysis)입니다.

### 05-3 하노이의 탑
- 하노이의 탑(Towers of Hanoi)은 작은 원반이 위에, 큰 원반이 아래에 위치할 수 있도록 원반을 3개의 기둥 사이에서 옮기는 문제입니다. 모든 원반은 크기	가 다르고 처음에는 모든 원반이 이 규칙에 맞게 첫 번째 기둥에 쌓여 있습니다. 이 상태에서 모든 원반을 세 번째 기둥으로 최소의 횟수로 옮기면 됩니다.

### 05-4 8퀸 문제
- 서로 공격하여 잡을 수 없도록 8개의 퀸을 8 X 8 체스판에 놓으세요.

1. `가지 뻗기(Branching)`
	- 이렇게 가지를 뻗으며 퀸을 배치하는 조합을 모두 나열하는 방법을 가지 뻗기(branching)라고 합니다. 하노이의 탑이나 8퀸 문제처럼 문제를 세분하고 세분된 작은 문제의 풀이를 결합해 전체 문제를 풀이하는 기법을 분할 해결법(divide and conquer)이라고 합니다.
	- 물론 문제를 세분할 때는 작은 문제의 풀이에서 원래 문제의 풀이가 쉽게 도출될 수 있게 설계해야 합니다.

2. `한정조작(Bounding)`
	- 이처럼 필요하지 않은 분기를 없개 불필요한 조합을 줄이는 방법을 한정조작이라하고, 가지 뻗기와 한정 조작을 조합하여 문제를 풀어가는 방법을 분기 한정법(branching and bounding method)이라고 합니다.

### ---`06 정렬`---
### 06-1 정렬(Sorting)
- 정렬(sorting)은 이름, 학번, 키 등 핵심 항목(key)의 대소 관계에 따라 데이터 집합을
일정한 순서로 줄지어 늘어서도록 바꾸는 작업을 말합니다. 키 값이 작은 데이터를 앞쪽에 놓으면 오름차순(ascending order) 정렬, 그 반대로 놓으면 내림차순(descending order) 정렬이라고 부릅니다.

- 정렬 알고리즘도 하나의 배열에서 작업할 수 있는 경우에는 내부 정렬(internal sorting)을 사용하고, 하나의 배열에서 작업할 수 없는 경우에는 외부 정렬(external sorting)을 사용합니다.
	- 내부 정렬 : 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘입니다.
	- 외부 정렬 : 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘입니다.

### 06-2 버블 정렬(Bubble Sort)
- 버블 정렬은 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복합니다.
- 요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동합니다. 그리고 이런 일련의 과정(비교, 교환 작업)을 패스(pass)라고 합니다.

### 06-3 단순 선택 정렬(Straight Selection Sort)
- 단순 선택 정렬은 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘입니다.

### 06-4 단순 삽입 정렬(Straight Insertion Sort)
- 단순 삽입 정렬은 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘입니다. 단순 선택 정렬과 비슷하게 보일 수 있지만 `단순 선택 정렬`은 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다는 점이 다릅니다.

### 06-5  셸 정렬(Shell Sort)
- 셸 정렬은 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘으로, 도널드 셸(D. L. Shell)이 고안했습니다. 먼저 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법입니다.
- 셸 정렬 과정에서 수행하는 각각의 정렬을 `h-정렬`이라고 합니다.

### 06-6 퀵 정렬(Quick Sort)
- 퀵 정렬은 일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘입니다. 퀵 정렬이라는 이름은 이 알고르짐의 정렬 속도가 매우 빠른데서 착안한 찰스 앤서니 리처드 호어(C. A. R. Hoare)가 직접 붙인 이름입니다. 그룹을 나누는 기준(요소)을 피벗(pivot)이라고 하는데 퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 나눈 그룹이 한 개의 요소를 가지게되면 정렬을 마칩니다.

### 06-7 병합 정렬(Merge Sort)
- 병합 정렬은 배열의 앞 부분과 뒷 부분으로 나누어 각각 정렬할 다음 병합하는 작업을 반복하여 정렬을 수핸하는 알고리즘입니다.

### 06-8 힙 정렬(Heap Sort)
- 선택 정렬을 응용한 알고리즘인 힙 정렬은 힙(heap)의 특성을 이용하여 정렬을 수행합니다.

"힙이란?"

- 힙 정렬은 힙을 사용하여 정렬하는 알고리즘입니다. 힙은 '부모의 값이 자식의 값보다 항상 크다'는 조건을 만족하는 완전이진트리입니다. 이때 부모의 값이 자식보다 항상 작아도 힙이라고 합니다.
- 힙 정렬은 '가장 큰 값이 루트에 위치'하는 특징을 이용하는 정렬 알고리즘입니다. 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고 그 값을 늘어놓으면 배열은 정렬을 마치게 됩니다. 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘이며 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 합니다. 다시 말해 힙으로 구성된 10개의 요소에서 가장 큰 값을 없애면 나머지 9개의 요소에서 가장 큰 값을 루트로 정해야 합니다. 따라서 나머지 9개의 요소로 만든 트리도 힙의 형태를 유지할 수 있도록 재구성 해야합니다.

### 06-9 도수 정렬(Counting Sort)
- 도수 정렬은 요소의 대소 관계를 판단하지 않고 빠르게 정렬할 수 있는 알고리즘입니다.
- 도수 정렬 알고리즘은 데이터의 비교, 교환 작업이 필요 없어 매우 빠릅니다. 단일 for문만을 사용하며 재귀 호출, 이중 for문이 없어 아주 효율적인 알고리즘입니다. 하지만 도수분포표가 필요하기 때문에 데이터의 최소값과 최대값을 미리 알고 있는 경우에만 사용할 수 있습니다.
	- 1단계 : 도수분포표 만들기
	- 2단계 : 누적도수분포표 만들기
	- 3단계 : 목적 배열 만들기
	- 4단계 : 배열 복사하기

### ---`08 문자열 검색`---
# 08-1 문자열의 기본
이번 장에서는 문자열 안에 들어 있는 부분 문자열을 검색하는 알고리즘을 살펴보겠습니다.
그런데 문자열을 다루는 알고리즘을 공부하려면 문자열의 기본을 먼저 알아야 합니다. 

### 문자열이란?
프로그램에서 문자의 '나열'을 나타내는 것이 문자열(string)입니다.
이때 문자의 '나열'은 어떤 문자가 항상 있어야 하는 것은 아닙니다.
문자가 하나만 있어도 좋고, 비어 있어도 상관없습니다.
빈 문자열도 문자열입니다.
- 문자열 리터럴 : C 언어에서는 "STRING"이나 "ABC"처럼 문자의 나열을 2개의 큰따옴표(")로 묶은 것을 문자열 리터럴(string literal)이라고 합니다.
- 문자열 안의 문자는 메모리 공간에 연속으로 배치됩니다.
