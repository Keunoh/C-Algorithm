//원하는 개수만큼 데이터를 입력하고, 요소의 개수가 n인 ㅂ열에는 최근에 입력한 n개만 저장
#include <stdio.h>

#define N 10		/* 저장하는 데이터의 개수 */

int main()
{
	int i;
	int a[N];		/* 입력한 데이터를 저장 */
	int cnt = 0;	/* 입력한 데이터의 개수 */
	int retry;		/* RETRY */
	puts("put integer");
	do {
		printf("%d번째 정수 : ", cnt + 1);
		scanf("%d", &a[cnt++ % N]);
		printf("wanna retry? (yes : 1/no : 0) : ");
		scanf("%d", &retry);
	} while (retry == 1);
	
	i = cnt - N;
	if(i < 0) i = 0;
	for(; i < cnt; i++)
		printf("%2d번째 정수 = %d\n", i + 1, a[i % N]);
		
	return 0;
}

/* [ 링 버퍼의 활용 ]
	링 버퍼는 '오래된 데이터를 버리는' 용도로 사용할 수 있습니다.
	구체적인 예를 들면 요소의 개수가 n인 배열에 계속해서 데이터가 입력될 때 가장 최근에 들어온 데이터 n개만 저장하고 오래된 데이터는 버리는 용도로 사용합니다.
	이런 방법으로 링 버퍼를 활용한 프로그램이 실습 4C-1입니다.
	배열 a의 요소 개수는 10개 입니다.
	정수 입력(인큐)은 무한히 할 수 있지만 배열에 저장되는 데이터는 가장 최근에 입력한 10개의 데이터만 링 버퍼에 남아있습니다. 

	그림 4C-1은 아래 12개의 정수를 입력하는 예입니다.
	// 15, 17, 64, 57, 99, 21, 0, 23, 44, 55, 97, 85
	
	그러나 배열에 남아 있는 요소는 가장 나중에 입력한 10개만 저장되고, 아래처럼 처음에 입력한 2개는 버려집니다.
	// 15, 17, 64, 57, 99, 21, 0, 23, 44, 55, 97, 85
	   <----> 15, 17은 버립니다. 
	
	실습 4C-1의 1에서는 입력한 값을 a[cnt++ % N]에 저장합니다.
	입력한 값이 어떤 과정으로 배열 요소에 저장되는지 자세히 살펴보겠습니다.
	
	// 1. 1번째 값 입력하기
	cnt는 0이고 10으로 나눈 나머지는 0입니다. 입력한 값은 a[0]에 저장됩니다.
	
	// 2. 2번째 값 입력하기
	cnt는 1이고 10으로 나눈 나머지는 1입니다. 입력한 값은 a[1]에 저장됩니다.
	
	... 중략 ...
	 
	// 3. 11번째 값 입력하기
	cnt는 10이고 10으로 나눈 나머지는 0입니다. 입력한 값은 a[0]에 저장됩니다. 
	1번째 위치의 데이터를 11번째 데이터가 덮어씁니다.
	
	// 4. 12번째 값 입력하기
	cnt는 11이고 10으로 나눈 나머지는 1입니다. 입력한 값은 a[1]에 저장됩니다. 
	2번째 위치의 데이터를 12번째 데이터가 덮어씁니다.
	
	입력한 값을 저장하는 위치의 인덱스를 'cnt++ % N'으로 구합니다.
	이렇게 구현한 프로그램에 임의의 값을 입력하면 입력된 값이 링 버퍼(배열)에 순환하며 저장되고 있음을 알 수 있습니다.
	그런데 입력한 값을 출력할 때 조금 더 생각해볼 내용이 있습니다.
	입력한 값의 개수(cnt)가 10 이하면 다음을 순서대로 출력해도 됩니다(출력할 값은 cnt개입니다).
	 
	// a[0] ~ a[cnt - 1]

	그러나 앞에서 수행한 대로 12개의 값을 입력하는 경우에는 다음과 같은 순서대로 출력해야 합니다(10개의 값을 출력해야 합니다).
	실습 4C-1의 프로그램은 나머지 연산자를 사용하여 간단하게 처리하고 있습니다.
	// 나머지 연산자를 사용하여 어떻게 처리했는데 프로그램을 꼼꼼하게 다시 한 번 읽어보세요.	 
*/



















