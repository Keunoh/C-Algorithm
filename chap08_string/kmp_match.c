/*--- KMP법으로 문자열을 검색 ---*/

#include <stdio.h>

int kmp_match (const char txt[], const char pat[])
{
	int pt = 1;		/* txt커서 */
	int pp = 0;		/* pat커서 */
	int skip[1024];	/* 건너뛰기 표 */
	
	skip[pt] = 0;
	while(pat[pt] != '\0') {
		if(pat[pt] == pat[pp])
			skip[++pt] = ++pp;
		else if(pp == 0)
			skip[++pt] = pp;
		else
			pp = skip[pp];
	} 
	
	pt = pp = 0;
	while(txt[pt] != '\0' && pat[pp] != '\0') {
		if(txt[pt] == pat[pp]) {
			pt++; pp++;
		} else if(pp == 0) {
			pt++;
		} else {
			pp = skip[pp];
		} 
	}
	
	if(pat[pp] == '\0')
		return pt - pp;
		
	return -1;
}

int main (void)
{
	int idx;
	char s1[256];	/* 텍스트 */
	char s2[256];	/* 패턴 */
	puts("KMP법");
	printf("텍스트 : "); scanf("%s", s1);
	printf("패턴 : "); scanf("%s", s2);
	
	idx = kmp_match(s1, s2);	/* 텍스트(s1)에서 패턴(s2)을 브루트-포스법으로 검색합니다. */
	if (idx == -1)
		puts("텍스트에 패턴이 없습니다.");
	else
		printf("%d번째 문자부터 match합니다.\n", idx + 1);
		
	return 0;	
}

/* [ KMP법 ]
	KMP법은 다른 문자를 만나면 패턴을 1칸씩 옮긴 다음 다시 패턴의 처음부터 검사하는 브루트-포스법과는 다르게 중간 검사 결과를 효율적으로 사용하는 알고리즘입니다. 
	
	브루트-포스법은 다른 문자를 만나면 패턴에서 문자를 검사했던 위치 결과를 버리고 다음 텍스트의 위치로 1칸 이동한 다음 다시 패턴의 첫 번째 문자부터 검사합니다.
	예를들어 "apple"이라는 텍스트에서 "app"이라는 패턴을 찾을 경우, 텍스트에서 패턴의 'a'를 찾은 다음에 텍스트의 'p'를 찾으려면 다시 패턴의 'a'부터 검사합니다.
	이렇게 하면 처음에 찾았던 패턴의 'a'부터 다시 검사하기 때문에 비효율적입니다.
	하지만 KMP법은 검사했던 위치 결과를 버리지 않고 이를 효율적으로 활용하는 알고리즘입니다.
	
	그러면 텍스트 "ZABCABXACCADEF"에서 패턴 "ABCABD"를 검색하는 경우를 예로 들어 KMP 알고리즘에 대해 알아보겠습니다.
	먼저 다음 그림과 같이 텍스트, 패턴의 첫 문자부터 순서대로 검사합니다.
	텍스트의 1번째 문자 'Z'는 패턴에 없는 문자이므로 일치하지 않는다고 판단합니다.
	
	그런 다음 패턴을 1칸 뒤로 이동시킵니다.
	이때 패턴을 처음부터 순서대로 검사하면 패턴의 마지막 문자는 'D'여서 텍스트의 X와 일치하지 않습니다. 
	여기서 텍스트의 초록색 문자 "AB"와 패턴의 "AB"가 일치한다는 점을 이용하면 됩니다.
	이 부분은 '이미 검사를 마친 부분'이므로 텍스트의 'X' 다음 문자부터 패턴의 "CABD"가 일치하는지만 검사하면 됩니다.
	그래서 다음과 같이 "AB"와 'X'를 한 번에(3칸) 이동시키고 3번째 문자인 'C'부터 검사하면 됩니다.
	
	이와 같이 KMP법은 텍스트와 패턴의 겹치는 부분을 찾아내어 검사를 다시 시작할 위치를 구합니다.
	이런 방법으로 패턴을 최소의 횟수로 옮겨 알고리즘의 효율을 높입니다.
	
	하지만 몇 번째 문자부터 다시 검색을 시작할지 패턴을 이동시킬 때마다 다시 계산해야 한다면 높은 효율을 기대할 수 없습니다.
	그래서 '몇 번째 문자부터 다시 검색할지'에 대한 값을 미리 '표'로 만들어 이 문제를 해결합니다.
	
	a~d : 패턴의 1~4번째 문자에서 검사에 실패한 경우에는 패턴을 옮긴 다음 1번째 문자부터 다시 검사합니다.
	e	: 패턴의 5번째 문자에서 검사에 실패한 경우에는 패턴을 옮긴 다음 1번째 문자가 일치하므로 2번째 문자부터 다시 검사할 수 있습니다.
	f	: 패턴의 6번째 문자에서 검사에 실패한 경우에는 3번째 문자부터 다시 검사할 수 있습니다.
	
	표를 작성할 때는 패턴 안에서 중복되는 문자의 나열을 먼저 찾아야 합니다. 이 과정에서 KMP법을 사용합니다. 
	패턴 안에서 중복되는 문자의 나열을 찾기 위해 패턴끼리 겹쳐놓고 생각해 보겠습니다.
	패턴의 1번째 문자가 서로 다른 경우 아래의 패턴을 1칸 뒤로 옮기고 1번째 문자부터 다시 검사합니다.
	
	패턴 "ABCABD"를 1칸 뒤로 옮긴 다음 겹칩니다.
	그림을 보면 초록색 부분이 겹치지 않으므로 패턴을 옮긴 다음 앞쪽의 1번째 문자부터 검사를 다시 시작해야 한다는 것을 알 수 있습니다.
	따라서 표에서 2번째 문자(B)의 값을 0으로 합니다.
	표에서 2번째 값이 0인 이유는 아래에 위치시킨 패턴의 첫 번째 문자의 인덱스가 0이고 이 위치에서 다시 검사를 시작하기 때문입니다.
	
	패턴을 1칸 뒤로 옮깁니다. 문자가 일치하지 않으므로 표에서 3번째 문자(C)의 값을 0으로 합니다.
	패턴을 1칸 뒤로 옮기면 "AB"가 일치합니다. 여기서 다음과 같은 사실을 알아낼 수 있습니다. 
	
	1. 패턴의 4번째 문자 'A'까지 일치한다면 아래에 위치한 패턴을 1칸 옮긴 다음 'A'를 건너뛰고 2번째 문자부터 검사할 수 있습니다.
	2. 패턴의 5번째 문자 'B'까지 일치한다면 아래에 위치한 패턴을 1칸 옮긴 다음 "AB"를 건너뛰고 3번째 문자부터 검사할 수 있습니다.
	
	따라서 표에서 두 문자의 값을 1, 2로 할 수 있습니다.
	이어서 아래에 위치한 패턴을 2칸 뒤로 옮기면 문자가 일치하지 않습니다.
	표에서 패턴의 마지막 문자 'D'의 값을 0으로 합니다.
	
	1에서 다시 시작 값의 표를 만들고 2에서 검색을 수행합니다.
	KMP법에서 텍스트를 스캔하는 커서 pt는 다시 뒤로 돌아오지 않습니다. 
	하지만 KMP법은 브루트-포스법보다는 복잡하고, 다음 절에서 공부할 Boyer-Moore법과는 성능이 같거나 좋지 않아 실제 프로그램에서는 거의 사용하지 않습니다. 
	 
*/
































