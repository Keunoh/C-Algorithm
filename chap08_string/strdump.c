/* 문자열 안의 문자를 16진수와 2진수로 출력합니다. */
#include <stdio.h>
#include <limits.h>

/*--- 문자열 안의 문자를 16진수와 2진수로 출력하는 함수 ---*/
void str_dump(const char *s) 
{
	do {
		int i;
		printf("%c %0*X ", *s, (CHAR_BIT + 3) / 4, *s);
		for(i = CHAR_BIT - 1; i >= 0; i--)
			putchar(((*s >> i) & 1U) ? '1' : '0');
		putchar('\n');
	} while (*s++ != '\0');
}

int main (void)
{
	str_dump("STRING");
	return 0;
}

/* 프로그램을 실행하면 위와 같은 결과를 확인할 수 있습니다. 그런데 문자열 리터럴은 내용을 자유롭게 바꿀 수 없습니다. 자유롭게 읽고 쓰는 문자열은 배열로 구현해야 합니다. */
/* [ 문자열 리터럴 ]
	여기서는 문자열 리터럴의 특징을 간단히 알아보겠습니다.
	
	1. 문자열 리터럴의 자료형
	문자열 리터얼의 자료형은 char형 배열입니다. 그러나 문자열 리터러의 표현식을 평가하여 얻는 자료형은 char*형이고 그 값은 첫 번째 문자에 대한 포인터입니다.
	예를 들어 문자열 리터럴"STRING"을 평가하면 첫 번째 글자 'S'에 대한 포인터를 얻습니다. 
	
	2. 문자열 리터럴의 메모리 영역 기간
	문자열 리터럴의 메모리 영역 기간은 정적 메모리 영역의 기간과 같습니다.
	그러므로 프로그램의 시작부터 끝까지 메모리 영역이 유지됩니다.
	
	3. 같은 문자열 리터럴이 여러 개 있는 경우 컴퓨터에서 처리하는 방법
	같은 문자열 리터럴이 여러 개 있는 경우에는 이를 각각 다른 메모리 영역에 넣어두는 컴퓨터 환경도 있고 같은 영역에 넣어두고 공유하는 컴퓨터 환경도 있습니다. 

	4. 상수의 성질을 갖는 문자열 리터 럴
	문자열 리터럴은 변수가 아니라 상수의 성질을 가지고 있습니다.
	즉, 문자열 리터럴이 저장된 메모리 영력에 값을 대입할 수 없습니다. 
*/
