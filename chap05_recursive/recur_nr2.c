/*--- 재귀 호출을 제거한 recur 함수 ---*/
#include "../chap04_stack_queue/IntStack.h"
#include "../chap04_stack_queue/IntStack.c"

void recur(int n) 
{
	IntStack stk;			/* 스택 */
	Initialize(&stk, 100);
	
	Top :
		if (n > 0) {
			Push(&stk, n);	/* n의 값을 푸시 */
			n = n - 1;
			goto Top;
		} 
		if (!IsEmpty(&stk)) {
			Pop(&stk, &n);
			printf("%d\n", n);
			n = n - 2;
			goto Top;
		}
		
	Terminate(&stk);
} 

/* [재귀의 제거]
	그런데 꼬리 재귀와는 다르게 앞에서 호출한 재귀 함수의 제거는 쉽지 않습니다.
	왜냐하면 변수 n의 값을 출력하기 전에 recur(n - 1)을 먼저 수행해야 하기 때문입니다.
	예를 들어, n이 4인 경우 재귀 호출 recur(3)의 처리가 완료되지 않으면 n의 값인 '4'를 저장해야합니다.
	그래서 재귀 호출 recur(n - 1)을 아래처럼 바로 바꿀 수 없습니다. 
	
	// n의 값을 n - 1로 업데이트하고 함수의 시작 지점으로 돌아갑니다.  
	
	왜냐하면 다음과 같은 처리를 미리 해야 하기 때문입니다.
	// 현재 n의 값을 '잠시' 저장합니다.
	
	또 recur(n - 1)의 처리가 완료된 다음에 n의 값을 출력할 때는 다음 과정을 따르게 됩니다.
	// 저장했던 n을 다시 꺼내 그 값을 출력합니다.
	
	이런 재귀 호출을 제거하기 위해서는 변수 n의 값을 '잠시' 저장해야 한다는 사실을 알았습니다.
	이때 이런 문제를 잘 해결할 수 있는 데이터 구조가 바로 앞 장에서 살펴본 스택(stack)입니다.
	위는 스택을 사용하여 비재귀적으로 구현한 recur 함수입니다. 
*/

/* recur(4)를 호출한 다음의 과정 살펴보기
	매개변수로 전달받은 값 '4'는 0보다 크므로 맨 앞의 if문에 의해 다음과 같은 과정이 진행됩니다.
	
	// 1. 4를 스택에 푸시합니다
	// 2. n의 값을 하나 줄여 3으로 만듭니다.
	// 3. goto문이 실행되어 레이블(Label) Top으로 돌아갑니다.
	
	3은 0보다 크므로 첫 번째 if문이 실행됩니다. 그 결과 위의 과정이 반복됩니다.
	그러면 그림 b -> 그림 c -> 그림 d의 순서대로 실행되면서 스택 4, 3, 2, 1이 쌓이게 됩니다.
	마지막으로 스택에 1을 쌓은 뒤 0이 되고 Top으로 돌아가서 맨 앞 if문이 실행됩니다.
	그러면 n 값이 0이므로 첫 번째 if문은 그냥 지나가고 다음의 if문에 의해 다음과 같은 과정이 진행됩니다.
	
	// 4. 스택에서 팝한 값 1을 n에 꺼내 놓습니다.
	// 5. n값 1을 출력합니다.
	// 6. n값을 2 줄여 -1로 만듭니다.
	// 7. goto문이 실행되어 레이블 Top으로 돌아갑니다.
	
	n값이 -1이므로 다시 뒤쪽의 if문이 실행되고 그림1처럼 스택에서 2가 팝(출력)됩니다.
	n이 0이하가 되어 스택이 텅 비면 두 if문 모두 실행되지 않고 종료됩니다. 
*/





















