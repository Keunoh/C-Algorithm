/* 재귀 알고리즘을 분석하기 위한 하향식(top bottom) 분석과 상향식(bottom up) 분석을 살펴보고 재귀 알고리즘을 비재귀적으로 구현하는 방법 */
/* 재귀에 대해 깊이 이해하기 위한 재귀 함수 */
#include <stdio.h>

void recur(int n) 
{
	if (n > 0) {
		recur(n - 1);
		printf("%d\n", n);
		recur(n - 2);
	}
}

int main(void)
{
	int x;
	printf("put integer : "); scanf("%d", &x);
	
	recur(x);
	
	return 0;
}

/* [하향식 분석]
	매개변수 n으로 4를 전달하면 recur 함수는 아래 과정을 순서대로 실행합니다.
	1. recur(3)을 실행합니다.
	2. 4를 출력합니다.
	3. recur(2)를 실행합니다.
	물론 2번에서 4를 출력하는 것은 1번의 recur(3)의 실행이 완료된 다음입니다.
	따라서 recur(3)을 먼저 조사해야합니다. 
	
	이처럼 가장 위쪽에 위치한 상자의 함수 호출부터 시작해 계단식으로 자세히 조사해 가는 분석 비법을 하향식 분석(top-bottom analysis)이라고 합니다.
	그런데 이 그림 안에는 recur(1), recur(2)의 호출이 여러 번 있습니다(같은 호출이 여러 번 있습니다).
	꼭대기(top)부터 분석하면 이렇게 같은 함수의 호출이 여러 번 나올 수 있기 때문에 '하향식 분석이 반드시 효율적이다'라고 말할 수는 없습니다. 
*/

/* [상향식 분석]
	위쪽부터 분석하는 하향식 분석과는 대조적으로 아래쪽부터 쌓아 올리며 분석하는 방법이 상향식 분석(bottom-up analysis)입니다.
	recur 함수는 n이 양수일 때만 실행하므로 먼저 recur(1)을 생각합니다.
	1. recur(0)을 실행합니다.
	2. 1을 출력합니다.
	3. recur(-1)을 실행합니다.
	여기서 1번의 recur(0)과 3번의 recur(-1)은 출력할 내용이 없습니다.
	따라서 2번의 1만 출력합니다.
	
	그럼 recur(2)에 대해 생각해봅시다.	
	1. recur(1)을 실행합니다.
	2. 2를 출력합니다.
	3. recur(0)을 실행합니다.
	1번의 recur(1)은 1을 출력하고 3번의 recur(0)은 출력할 내용이 없습니다.
	전체 과정을 거치면 1과 2를 출력합니다.
	이 작업을 recur(4)까지 쌓아 올려 설명한 내용이 아래 그림과 같습니다.
	
	recur(1) : recur(0) 1 recur(-1) => 1
	recur(2) : recur(1) 2 recur(0)  => 1 2
	recur(3) : recur(2) 3 recur(1)  => 1 2 3 1
	recur(4) : recur(3) 4 recur(2)  => 1 2 3 1 4 1 2 
*/





















